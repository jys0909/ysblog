[{"title":"找回iphone 访问限制密码","date":"2017-06-22T22:50:40.000Z","path":"2017/06/22/找回iphone 访问限制密码/","text":"最近不小心把 iphone 5s的访问限制密码忘记了， 下面记录找回密码方法: 1. 下载 iBackupBot for iTunesiBackupBot官方版是一个为iPad，iPhone和iPod Touch等苹果设备专用的备份管理器软件。iBackupBot可以直接读取备份文件资料，不论是通讯录、短信内容、通话记录、还是照片，都能在其中找到，你只需选择正确的备份文件然后搜索响应的目录直接就能导入导出，甚至还能恢复游戏记录。单独恢复通讯录只需用手机连接电脑，在iBackupBot中打开iTunes备份，选中AddressBook.sqlitedb和AddressBookImages.sqlitedb这实际上就是通讯录的数据库文件备份，点击上方恢复到手机就行了，之后手机就如同在itunes下做恢复一样，不同的是你只恢复了通讯录，非常好用。点击下载 2. 安装iTunes,安装好后打开iTunes, 找到资料， 然后进行备份 3. 运行iBackupBot找到 System Files/HomeDomain/Library/Preferences 目录下com.apple.restrictionspassword.plist文件， 并打开， 找到下面的代码12345678910&lt;dict&gt; &lt;key&gt;RestrictionsPasswordKey&lt;/key&gt; &lt;data&gt; HxfREedr37oisGRd+lduyLHkw== &lt;/data&gt; &lt;key&gt;RestrictionsPasswordSalt&lt;/key&gt; &lt;data&gt; B7hsGA== &lt;/data&gt; &lt;/dict&gt; 4. 打开解密网站 http://ios7hash.derson.us/对应输入 RestrictionsPasswordKey 和 RestrictionsPasswordSalt 的值 HxfREedr37oisGRd+lduyLHkw==和B7hsGA==后， 点击 Search for Code按钮， 速度很快， 最多20来分钟就可完成解密 5. 另外一个方法在第3步中同一目录中找到COM.APPLE.SPRINGBOARD.PLIST文件打开文件， 找到如下代码：123&lt;key&gt;countryCode&lt;/key&gt; &lt;string&gt;cn&lt;/string&gt;&lt;/dict&gt; 在这代码下加入下面代码12&lt;key&gt;SBParentalControlsPIN&lt;/key&gt;&lt;string&gt;1234&lt;/string&gt; 1234就是你的新访问限制密码 保存，并退出iBackupBot 然后在iturns里恢复刚修改过的备份到你的设备","tags":[{"name":"个人整理","slug":"个人整理","permalink":"http://www.g5kk.com/tags/个人整理/"}]},{"title":"React Electron 创建简单桌面应用","date":"2017-06-20T12:45:40.000Z","path":"2017/06/20/React electron 桌面应用/","text":"Electron简介Electron提供了丰富的本地（操作系统）的API，使你能够使用纯JavaScript来创建桌面应用程序 全局安装Electron1npm install electron -g 使用方法需要3个文件1231. main.js2. package.json3. index.html main.jsmain.js是在根目录， 而不是src目录，内容如下：对英文菜单实在不感冒， 换成了中文。123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304const electron = require(&apos;electron&apos;)const BrowserWindow = electron.BrowserWindow// const Menu = electron.Menuconst app = electron.appconst path = require(&apos;path&apos;)const url = require(&apos;url&apos;)const pkg = require(&apos;./package.json&apos;)const Menu = electron.Menu// Keep a global reference of the window object, if you don&apos;t, the window will// be closed automatically when the JavaScript object is garbage collected.let winlet template = [&#123; label: &apos;编辑&apos;, submenu: [&#123; label: &apos;撤销&apos;, accelerator: &apos;CmdOrCtrl+Z&apos;, role: &apos;undo&apos; &#125;, &#123; label: &apos;重做&apos;, accelerator: &apos;Shift+CmdOrCtrl+Z&apos;, role: &apos;redo&apos; &#125;, &#123; type: &apos;separator&apos; &#125;, &#123; label: &apos;剪切&apos;, accelerator: &apos;CmdOrCtrl+X&apos;, role: &apos;cut&apos; &#125;, &#123; label: &apos;复制&apos;, accelerator: &apos;CmdOrCtrl+C&apos;, role: &apos;copy&apos; &#125;, &#123; label: &apos;粘贴&apos;, accelerator: &apos;CmdOrCtrl+V&apos;, role: &apos;paste&apos; &#125;, &#123; label: &apos;全选&apos;, accelerator: &apos;CmdOrCtrl+A&apos;, role: &apos;selectall&apos; &#125;]&#125;, &#123; label: &apos;查看&apos;, submenu: [&#123; label: &apos;重载&apos;, accelerator: &apos;CmdOrCtrl+R&apos;, click: function (item, focusedWindow) &#123; if (focusedWindow) &#123; // 重载之后, 刷新并关闭所有的次要窗体 if (focusedWindow.id === 1) &#123; BrowserWindow.getAllWindows().forEach(function (win) &#123; if (win.id &gt; 1) &#123; win.close() &#125; &#125;) &#125; focusedWindow.reload() &#125; &#125; &#125;, &#123; label: &apos;切换全屏&apos;, accelerator: (function () &#123; if (process.platform === &apos;darwin&apos;) &#123; return &apos;Ctrl+Command+F&apos; &#125; else &#123; return &apos;F11&apos; &#125; &#125;)(), click: function (item, focusedWindow) &#123; if (focusedWindow) &#123; focusedWindow.setFullScreen(!focusedWindow.isFullScreen()) &#125; &#125; &#125;, &#123; label: &apos;切换开发者工具&apos;, accelerator: (function () &#123; if (process.platform === &apos;darwin&apos;) &#123; return &apos;Alt+Command+I&apos; &#125; else &#123; return &apos;Ctrl+Shift+I&apos; &#125; &#125;)(), click: function (item, focusedWindow) &#123; if (focusedWindow) &#123; focusedWindow.toggleDevTools() &#125; &#125; &#125;, &#123; type: &apos;separator&apos; &#125;, &#123; label: &apos;应用程序菜单演示&apos;, click: function (item, focusedWindow) &#123; if (focusedWindow) &#123; const options = &#123; type: &apos;info&apos;, title: &apos;应用程序菜单演示&apos;, buttons: [&apos;好的&apos;], message: &apos;此演示用于 &quot;菜单&quot; 部分, 展示如何在应用程序菜单中创建可点击的菜单项.&apos; &#125; electron.dialog.showMessageBox(focusedWindow, options, function () &#123;&#125;) &#125; &#125; &#125;]&#125;, &#123; label: &apos;窗口&apos;, role: &apos;window&apos;, submenu: [&#123; label: &apos;最小化&apos;, accelerator: &apos;CmdOrCtrl+M&apos;, role: &apos;minimize&apos; &#125;, &#123; label: &apos;关闭&apos;, accelerator: &apos;CmdOrCtrl+W&apos;, role: &apos;close&apos; &#125;, &#123; type: &apos;separator&apos; &#125;, &#123; label: &apos;重新打开窗口&apos;, accelerator: &apos;CmdOrCtrl+Shift+T&apos;, enabled: false, key: &apos;reopenMenuItem&apos;, click: function () &#123; app.emit(&apos;activate&apos;) &#125; &#125;]&#125;, &#123; label: &apos;帮助&apos;, role: &apos;help&apos;, submenu: [&#123; label: &apos;学习更多&apos;, click: function () &#123; electron.shell.openExternal(&apos;http://electron.atom.io&apos;) &#125; &#125;]&#125;]function addUpdateMenuItems (items, position) &#123; if (process.mas) return const version = electron.app.getVersion() let updateItems = [&#123; label: `Version $&#123;version&#125;`, enabled: false &#125;, &#123; label: &apos;正在检查更新&apos;, enabled: false, key: &apos;checkingForUpdate&apos; &#125;, &#123; label: &apos;检查更新&apos;, visible: false, key: &apos;checkForUpdate&apos;, click: function () &#123; require(&apos;electron&apos;).autoUpdater.checkForUpdates() &#125; &#125;, &#123; label: &apos;重启并安装更新&apos;, enabled: true, visible: false, key: &apos;restartToUpdate&apos;, click: function () &#123; require(&apos;electron&apos;).autoUpdater.quitAndInstall() &#125; &#125;] items.splice.apply(items, [position, 0].concat(updateItems))&#125;function findReopenMenuItem () &#123; const menu = Menu.getApplicationMenu() if (!menu) return let reopenMenuItem menu.items.forEach(function (item) &#123; if (item.submenu) &#123; item.submenu.items.forEach(function (item) &#123; if (item.key === &apos;reopenMenuItem&apos;) &#123; reopenMenuItem = item &#125; &#125;) &#125; &#125;) return reopenMenuItem&#125;if (process.platform === &apos;darwin&apos;) &#123; const name = electron.app.getName() template.unshift(&#123; label: name, submenu: [&#123; label: `关于 $&#123;name&#125;`, role: &apos;about&apos; &#125;, &#123; type: &apos;separator&apos; &#125;, &#123; label: &apos;服务&apos;, role: &apos;services&apos;, submenu: [] &#125;, &#123; type: &apos;separator&apos; &#125;, &#123; label: `隐藏 $&#123;name&#125;`, accelerator: &apos;Command+H&apos;, role: &apos;hide&apos; &#125;, &#123; label: &apos;隐藏其它&apos;, accelerator: &apos;Command+Alt+H&apos;, role: &apos;hideothers&apos; &#125;, &#123; label: &apos;显示全部&apos;, role: &apos;unhide&apos; &#125;, &#123; type: &apos;separator&apos; &#125;, &#123; label: &apos;退出&apos;, accelerator: &apos;Command+Q&apos;, click: function () &#123; app.quit() &#125; &#125;] &#125;) // 窗口菜单. template[3].submenu.push(&#123; type: &apos;separator&apos; &#125;, &#123; label: &apos;前置所有&apos;, role: &apos;front&apos; &#125;) addUpdateMenuItems(template[0].submenu, 1)&#125;if (process.platform === &apos;win32&apos;) &#123; const helpMenu = template[template.length - 1].submenu addUpdateMenuItems(helpMenu, 0)&#125;function createWindow() &#123; // Create the browser window. win = new BrowserWindow(&#123;width: 1100, height: 800&#125;) // and load the index.html of the app. win.loadURL(url.format(&#123; pathname: // path.join(__dirname, &apos;./build/index.html&apos;), protocol: &apos;file:&apos;, // slashes: true &#125;)) 判断是否是开发模式 // if (pkg.DEV) &#123; win.loadURL(&quot;http://localhost:3000/&quot;) // &#125; else &#123; // win.loadURL(url.format(&#123; // pathname: path.join(__dirname, &apos;./build/index.html&apos;), // protocol: &apos;file:&apos;, // slashes: true // &#125;)) // &#125; // win.loadURL(&apos;http://localhost:3000/&apos;) Open the DevTools. // win.webContents.openDevTools() // console.log(win.webContents); // Emitted when the window is closed. win.on(&apos;closed&apos;, () =&gt; &#123; // Dereference the window object, usually you would store windows in an array if // your app supports multi windows, this is the time when you should delete the // corresponding element. win = null &#125;)&#125;// This method will be called when Electron has finished initialization and is// ready to create browser windows. Some APIs can only be used after this event// occurs.app.on(&apos;ready&apos;, function () &#123; createWindow(); const menu = Menu.buildFromTemplate(template) Menu.setApplicationMenu(menu)&#125;)app.on(&apos;browser-window-created&apos;, function () &#123; let reopenMenuItem = findReopenMenuItem() if (reopenMenuItem) reopenMenuItem.enabled = false&#125;)// app.on(&apos;window-all-closed&apos;, function () &#123;// let reopenMenuItem = findReopenMenuItem()// if (reopenMenuItem) reopenMenuItem.enabled = true// &#125;)// Quit when all windows are closed.app.on(&apos;window-all-closed&apos;, () =&gt; &#123; // On macOS it is common for applications and their menu bar to stay active // until the user quits explicitly with Cmd + Q win = null let reopenMenuItem = findReopenMenuItem() if (reopenMenuItem) reopenMenuItem.enabled = true if (process.platform !== &apos;darwin&apos;) &#123; app.quit() &#125;&#125;)app.on(&apos;activate&apos;, () =&gt; &#123; // On macOS it&apos;s common to re-create a window in the app when the dock icon is // clicked and there are no other windows open. if (win === null) &#123; createWindow() &#125;&#125;)// In this file you can include the rest of your app&apos;s specific main process// code. You can also put them in separate files and require them here. package.json在package.json下添加如下代码：12&quot;main&quot;: &quot;./main.js&quot;,&quot;homepage&quot;: &quot;.&quot; React 项目build后生成build文件夹， 将里面的index当作win启动文件。最后在项目下运行：1electron .","tags":[{"name":"个人整理","slug":"个人整理","permalink":"http://www.g5kk.com/tags/个人整理/"}]},{"title":"JQuery + Gulp + Bootstrap + browserify + Express 搭建前端框架","date":"2017-05-26T15:10:39.000Z","path":"2017/05/26/jq-bt-express-bw/","text":"初始化项目新建项目文件夹 web12&gt; cd web &gt; express 修改app.js1234app.set(&apos;views&apos;, path.join(__dirname, &apos;views&apos;));// setting view engineapp.set(&apos;view engine&apos;, &apos;html&apos;);app.engine(&apos;html&apos;, require(&apos;ejs-mate&apos;)); 这样我们就可以使用.html文件来编写代码了, 将view下面自动生成的.ejs改成.html 安装 browserify, JQuery, Bootstrap ,browserify-shim1234npm install browserify --save npm install browserify-shim --save // 可以使用似如jquery的插件变npm install jquery --savenpm install bootstrap --save browserify-shim 如何使用？在package.json下面添加如下内容12345678910111213141516171819202122232425&quot;browserify&quot;: &#123; &quot;transform&quot;: [ &quot;browserify-shim&quot; ] &#125;, &quot;browser&quot;: &#123; // 添加jquery.pep 插件 &quot;jquery.pep&quot;: &quot;./node_modules/jquery.pep.js/src/jquery.pep.js&quot;, // 添加bootstrap插件 &quot;bootstrap&quot;: &quot;./node_modules/bootstrap/dist/js/bootstrap.min.js&quot; &#125;, &quot;browserify-shim&quot;: &#123; // 添加jquery.pep 插件 &quot;jquery.pep&quot;: &#123; &quot;depends&quot;: [ &quot;jquery:jQuery&quot; ] &#125;, // 添加bootstrap插件 &quot;bootstrap&quot;: &#123; &quot;depends&quot;: [ &quot;jquery:jQuery&quot; ] &#125; &#125; 安装 Gulp 1npm install gulp -g 根目录添加gulpfile.js内容如下 12345678910111213141516171819 var gulp = require(&quot;gulp&quot;);var browserify = require(&quot;browserify&quot;);var sourcemaps = require(&quot;gulp-sourcemaps&quot;);var source = require(&apos;vinyl-source-stream&apos;);var buffer = require(&apos;vinyl-buffer&apos;); gulp.task(&quot;browserify&quot;, function () &#123; var b = browserify(&#123; entries: &quot;./static/src/main.js&quot;, debug: false &#125;); return b.bundle() .pipe(source(&quot;bundle.js&quot;)) .pipe(buffer()) .pipe(sourcemaps.init(&#123;loadMaps: true&#125;)) .pipe(sourcemaps.write(&quot;.&quot;)) .pipe(gulp.dest(&quot;./static/dist&quot;));&#125;); 意思是创建browserify任务， 执行browserify编译1&gt; gulp browserify 会将./static/src/main.js文件及所有依赖打包成.static/dist/bundle.js main.js1234567var $ = require(&quot;jquery&quot;);require(&quot;bootstrap&quot;); require(&quot;jquery.pep&quot;);$(&quot;.move-box&quot;).pep(&#123; useCSSTranslation: false, constrainTo: &apos;parent&apos;&#125;); 然后index.html 中引用.static/dist/bundle.js就可以了 注： browserify 也可以打包并可以调试1browserify main.js --debug | exorcist bundle.js.map &gt; bundle.js 也可以给gulp添加一个watch123gulp.task(&quot;watch&quot;,function()&#123; gulp.watch(&quot;./static/src/main.js&quot;,[&quot;browserify&quot;]);&#125;); 这时候修改main.js可以看出效果了 gulp绑定多个文件 如果构建的js很多，添加如下插件12cnpm install gulp-rename --savecnpm install event-stream --save 修改gulpfile.js文件1234567891011121314151617181920212223242526var rename = require(&apos;gulp-rename&apos;);var browserify = require(&apos;browserify&apos;);var es = require(&apos;event-stream&apos;);gulp.task(&apos;browserify&apos;, function()&#123; //定义多个入口文件 var entityFiles = [ &apos;./static/src/main.js&apos;, &apos;./static/src/log.js&apos;, ]; //遍历映射这些入口文件 var tasks = entityFiles.map(function(entity)&#123; return browserify(&#123;entries: [entity]&#125;) .bundle() .pipe(source(entity)) .pipe(rename(&#123; extname: &apos;.bundle.js&apos;, dirname: &apos;&apos; &#125;)) .pipe(gulp.dest(&apos;./static/dist&apos;)); &#125;); //创建一个合并流 return es.merge.apply(null, tasks);&#125;); 下面看另一种glob插件方法1cnpm install glob --save; 12345678910111213141516171819202122232425262728var gulp = require(&apos;gulp&apos;);var source = require(&apos;vinyl-source-stream&apos;);var rename = require(&apos;gulp-rename&apos;);var browserify = require(&apos;browserify&apos;);var es = require(&apos;event-stream&apos;);var glob = require(&apos;glob&apos;);gulp.task(&apos;browserify&apos;, function(done)&#123; glob(&apos;./static/src/*.js&apos;, function(err, files) &#123; if(err) done(err); var tasks = files.map(function(entry) &#123; return browserify(&#123; entries: [entry] &#125;) .bundle() .pipe(source(entry)) .pipe(rename(&#123; extname: &apos;.bundle.js&apos;, dirname: &apos;&apos; &#125;)) .pipe(gulp.dest(&apos;./static/dist&apos;)); &#125;); es.merge(tasks).on(&apos;end&apos;, done); &#125;)&#125;);gulp.task(&quot;watch&quot;,function()&#123; gulp.watch(&quot;./static/src/*.js&quot;,[&quot;browserify&quot;]);&#125;); 随便介绍下 合并压缩Css用到的包12345ar concat = require(&apos;gulp-concat&apos;); //- 多个文件合并为一个；var cssmin = require(&apos;gulp-minify-css&apos;); //- 压缩CSS为一行；var rev = require(&apos;gulp-rev&apos;); //- 对文件名加MD5后缀var revCollector = require(&apos;gulp-rev-collector&apos;); //- 路径替换var cssver = require(&apos;gulp-make-css-url-version&apos;); 在gulpfile.js中添加如下代码12345678910111213141516171819gulp.task(&apos;Cssmin&apos;, function() &#123; //- 创建一个名为 concat 的 task gulp.src(&apos;./static/css/*.css&apos;) //- 需要处理的css文件 .pipe(cssver()) .pipe(concat(&apos;default.min.css&apos;)) // 合并成一个文件名 .pipe(rev()) // 文件名加MD5后缀 .pipe(cssmin()) // 压缩成一行 .pipe(gulp.dest(&apos;./static/dist&apos;)) // 输出文件本地 .pipe(rev.manifest()) //- 生成一个rev-manifest.json .pipe(gulp.dest(&apos;./static/rev&apos;)); //- 将 rev-manifest.json 保存到 rev 目录内 &#125;);gulp.task(&apos;rev&apos;, function() &#123; gulp.src([&apos;./static/rev/*.json&apos;, &apos;./view/*.html&apos;]) //- 读取 rev-manifest.json 文件以及需要进行css名替换的文件 .pipe(revCollector()) //- 执行文件内css名的替换 .pipe(gulp.dest(&apos;./view/&apos;)); //- 替换后的文件输出的目录&#125;);gulp.task(&apos;default&apos;, [&apos;Cssmin&apos;, &apos;rev&apos;]);","tags":[{"name":"个人整理","slug":"个人整理","permalink":"http://www.g5kk.com/tags/个人整理/"}]},{"title":"如何在 React+Redux 的项目中更优雅的实现前端自动化测试","date":"2017-05-16T17:30:39.000Z","path":"2017/05/16/react-redux-test/","text":"乘着改革开放的浪潮，这段时间我们终于接触到非常火热的前端项目构架React+Redux。 这个构架下的前端项目，最大的优点就是Redux鼓励各个组件无状态化(no state)，利用store统一管理state，从而使各个组件之间相对更加独立和易于维护，使得前端的构架更加简单化。下图中左边是经典React中各组件的层级关系，右边是引入Redux之后的层级。在左图中，当修改父节点/组件时，子组件也可能会被破坏掉；而右图中能够影响到各个组件的因素只有state。 在传统JS Web项目中的自动化测试，通常会有这些比较突出的问题 UI自动化功能测试受制于环境(运行os,浏览器等)维护困难，运行缓慢，而且非常容易因为前端变化而被破坏。 单元测试覆盖点有限，无法覆盖所有的测试点。 那么作为新技术的React+Redux的出现，会不会给也测试带来一些新的思路或者机会来解决这些问题呢？比如放弃掉经典的UI自动化测试？ 作为浸泡在测试金字塔理论中多年的吃瓜的测试群众，我对越低层的测试成本更少、反馈问题更快这个道理深以为然。所以在面对这样的新鲜事物的时候，总愿意去分析下是否可以结合项目的技术特点，尽量把自动化测试往低层移，减少成本，加速反馈周期。还可以把锅甩给研发同学。 分析可行性为了分析技术上实现的可行性，我们至少需要知道React和Redux的一些基本概念： Store : 全局唯一的对象，用来保存state State : 某个时间点上state的快照，和改时间点上的view应该是一一对应的 Action : view 通过store.dispatch(action)发出的通知，表示 state 应该要发生变化了。 Reducer : 接受action和当前state，返回新的state的函数 UI Component : 纯负责显示UI，无状态 Container (Component): 负责一些业务逻辑和connect UI组件 Provider : React-Redux库的让react组件拿到新的state的方法 还需要了解Redux大致的工作流程： 用户操作view触发action store被action通知state要变化了，调用reducer reducer计算新的 state应该是啥样，返回新的state给store store通过react组件把新的state对应的view显示给客户 我刚好写了个简单的demo，能大概看懂这个demo中，各个组件是做什么的，如何工作的，对后面的内容有极大帮助。demo使用了webpack作为打包和本地运行工具 这么看起来，redux通过state-view一一对应的架构保证了只要view变，state一定变，反之亦然。这种一一对应的关系减少了组件之间发生关联(变化)的可能性，从而减轻了测试复杂度。最后再总结一下，发现针对该架构的自动化测试其实只需要保证下面几点就够了： 各个单独组件能够正常显示DOM元素 如果state改变了, 那么我只需要确保相应的view发生了变化 如果view发生了改变, 那么我只需要确保相应的state存进了store 验证分析结果从上面儿的分析结果来看，只用低层测试来保证质量的想法，好像有点儿靠谱的样子。接下来就是做一些小的demo来验证下真实项目中是否行得通。 好的单元测试应该有哪些特点呢？ 简单易懂。最好是BDD风格的，一眼就可以看出你在测试什么，减少维护成本 高覆盖率，研发重构的时候会更有信心 跑的快，不要有额外的工作(例如维护复杂的环境依赖等) 从客户价值(business value)角度出发，确保软件的可交付性。 那么首先，我们应该是尽量选择一款满足上面需求的测试工具。 测试工具选择满足上面条件的JS前端单元测试工具/框架很多，比较流行的是mocha+chai、JEST等。这里我们使用JEST测试框架和Enzyme测试工具库。 经过实际使用后发现，JEST对比Mocha来说，虽然运行速度上感觉比Mocha稍慢，但是因为如下几个优点最后胜出： 和React师出同门，FB官方支持 已经集成了测试覆盖率检查、mock等功能，不需要安装额外的库 文档完备，官方提供了和babel、webpack集成情况下以及异步调用的测试解决方案 官方提供snapshot testing解决方案 安装JEST 和 Enzyme 官方提供了详细的安装指导，实际安装完成后发现还是有坑。这里把安装过程重新梳理下。 首先是JEST1npm install --save-dev jest 如果需要在测试项目中使用babel，还需要额外安装babel-jest,1npm install --save-dev babel-jest 然后是Enzyme,1npm install enzyme --save-dev 如果使用的是react13以上的版本，则需要额外安装react-addons-test-utils1npm i --save-dev react-addons-test-utils 配置安装完成后，就可以开始写测试啦~不要方！JEST运行基础功能虽然无需配置，但是官方依然提供了配置选项来实现个性化需求。 例如，在单元测试覆盖率检查的时候，默认只检查被测试文件所使用到的源文件的覆盖率。然而，我们可以通过在package.json文件中配置jest的collectCoverageFrom参数，来指定检查所有需要测试的文件(无论源文件有没有被测试文件使用到） 以上面提到的demo为例。我们需要确定单元测试的范围–目标测试的文件是src文件夹下面的.jsx或者js文件，同时需要忽略其中的一些配置性质的jsx/js，比如store.js、provider.jsx和用于合并reducer的index.js。另外，还有覆盖率检查的时候生成coverage文件夹下面的js，编译后在dist文件夹下面生成的js文件，以及webpack的config文件都不需要测试。那么我们就在package.json里面加上这样一段内容1234567891011&quot;jest&quot;: &#123; &quot;collectCoverageFrom&quot; : [ &quot;**/*.&#123;js,jsx&#125;&quot;, &quot;!**/coverage/**&quot;, &quot;!**/dist/**&quot;, &quot;!**/store.js&quot;, &quot;!**/provider.jsx&quot;, &quot;!**/index.js&quot;, &quot;!**/webpack.config.js&quot; ] &#125; 然后给我们单元测试的覆盖率定个小目标，95%吧。只有当测试覆盖率大于等于这个比例的时候测试才会通过。123456789101112131415161718&quot;jest&quot;: &#123; &quot;collectCoverageFrom&quot; : [ &quot;**/*.&#123;js,jsx&#125;&quot;, &quot;!**/coverage/**&quot;, &quot;!**/store.js&quot;, &quot;!**/provider.jsx&quot;, &quot;!**/index.js&quot;, &quot;!**/webpack.config.js&quot; ], &quot;coverageThreshold&quot;: &#123; &quot;global&quot;: &#123; &quot;branches&quot;: 95, &quot;functions&quot;: 95, &quot;lines&quot;: 95, &quot;statements&quot;: 95 &#125; &#125;&#125; JEST配置选项有很多有用的功能，例如指定加载启动文件、指定moduleNameMapper、指定别名等。详见这里。 最后，我们还要给执行JEST加上一个命令：在package.json文件的scripts区域中增加一句1234&quot;scripts&quot;: &#123; ... &quot;test&quot;: &quot;jest&quot;&#125; 这样，我们就可以通过 npm test 命令来跑测试了。 实现单元测试工具准备完成，就可以开始写测试啦~不要方！我们知道Redux基本概念中的store等组件的功能和目的各不相同，那么针对各种组件的特性，我们分别应该如何测试呢？翻看Redux官网，发现这里有详细的例子和介绍，附上官网传送门。 需要注意的是，UI Component由于无状态化，和只负责显示DOM的作用，所以针对它们的单元测试只需要验证是否按预期显示了DOM就行了。组件中的props、方法等则无需测试。 还是以demo中的代码为例子。我们footer.jsx组件的代码是酱紫的：12345678910111213141516171819202122232425262728import React from &apos;react&apos;export default class Footer extends React.Component &#123; constructor() &#123; super() this.handleClick = this.handleClick.bind(this) &#125; handleClick()&#123; this.props.onClick() &#125; render()&#123; return( &lt;div style=&#123;styles.base&#125;&gt; &lt;footer&gt; &lt;a onClick=&#123;this.handleClick&#125;&gt;click footer to back&lt;/a&gt; &lt;/footer&gt; &lt;/div&gt; ) &#125;&#125;Footer.propTypes = &#123; onClick: React.PropTypes.func.isRequired&#125; 其中render()是React中负责显示DOM的代码, handleClick()是一个自定义方法，onClick则是一个props。再来看看测试代码footer.test.js1234567891011121314import React from &apos;react&apos;import &#123; shallow &#125; from &apos;enzyme&apos;import Footer from &apos;../../src/components/UIs/footer&apos;const props = &#123; onClick: jest.fn()&#125;describe(&apos;Footer component&apos;, () =&gt; &#123; it(&apos;should render dom&apos;, () =&gt; &#123; const wrapper = shallow(&lt;Footer &#123;...props&#125;/&gt;) expect(wrapper.find(&apos;a&apos;).text()).toContain(&apos;click footer&apos;) &#125;)&#125;) 测试代码中使用了enzyme库中的shallow功能。shallow是官方测试工具库react-addons-test-utils中shallow rendering的封装。是将一个组件渲染成虚拟DOM对象的“浅渲染”。这种渲染不会涉及子组件，不需要DOM，速度非常快。 源代码中onClick后调用的方法，在这里被JEST自带的mocked方法jest.fn()代替掉了，我们这个测试只测试了组件是否被正常显示出来了。expect部分是断言，实现内容是在被渲染出的footer组件中找到a标签，然后断言它的text()中有没有包含期望的文字。通过这种方式我们可以得知组件是否有被显示出来。 除了text()属性以外，还可非常灵活的通过其他方式来得知组件是否被正常显示。例如： 12expect(wrapper.find(&apos;button&apos;).exists()).toBeTruthy()expect(wrapper.find(&apos;input&apos;).props().type).toBe(&apos;text&apos;) 前者是断言被渲染出的组件中是否有button标签的存在；后者是断言组件中的input标签是否有type=”text”这个属性。 针对各个action、reducer和UI Component的测试写完成后，我们来运行下测试，查看覆盖率。 Tips: 可以通过npm test &lt;测试文件名&gt; 运行单个测试 这个时候我们就看到了之前配置的测试覆盖率检查范围的作用了：报告明确告诉了我们，app.jsx没有被测试到。另外，在footer.jsx中还有第19行以及userName.jsx第34行也没有被测试到，覆盖率一片红.. 检查了下未被覆盖的footer 19行和userName 34行，发现正是之前特意忽略掉的UI Component内的方法。app.jsx是一个Container组件，还没有写任何测试。 实现功能测试发现问题了，那就赶紧补测试吧~不要方！我们先来仔细分析下。 容器(container)组件的主要作用是链接UI组件，里面可能也包含了一些业务逻辑 UI Component中的方法，最终会通过容器组件对组件的调用而被调用到。 那么换句话说，我只需要按照功能测试的方法，以user journey的角度来测试这个组件，就可以覆盖到所有东西咯？再拿demo来练练手。 先确定demo的功能和user journey是： 用户输入任意字符，输入的同时，会在下方显示出输入的值 点击Submit按钮后提交form，更新界面显示 点击footer后可以回到首页 那么我们测试的内容就应该是：123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051import React from &apos;react&apos;import &#123; createStore &#125; from &apos;redux&apos;import &#123; mount &#125; from &apos;enzyme&apos;import &#123; Provider &#125; from &apos;react-redux&apos;import ReactDom from &apos;react-dom&apos;import App from &apos;../../src/components/app&apos;import Reducer from &apos;../../src/reducers&apos;let storelet wrapperconst fillin = (byCssSelector, text) =&gt; &#123; wrapper.find(byCssSelector).simulate(&apos;change&apos;, &#123;target: &#123;value:text&#125;&#125;)&#125;beforeEach( () =&gt; &#123; store = createStore(Reducer) wrapper = mount ( &lt;Provider store=&#123;store&#125;&gt; &lt;App /&gt; &lt;/Provider&gt; )&#125;)describe(&apos;User journey&apos;, ()=&gt; &#123; describe(&apos;user input a string in the field&apos;, ()=&gt; &#123; it(&apos;should display inputed name&apos;, ()=&gt; &#123; fillin(&apos;#userName&apos;, &apos;Han mei 妹@&apos;) expect(wrapper.find(&apos;#userInput&apos;).text()).toContain(&apos;Han mei 妹@&apos;) &#125;) &#125;) describe(&apos;click submit button&apos;, ()=&gt; &#123; it(&apos;should show welcome page, and original view disappear&apos;, ()=&gt; &#123; fillin(&apos;#userName&apos;, &apos;李磊@_@&apos;) wrapper.find(&apos;form&apos;).simulate(&apos;submit&apos;) expect(wrapper.find(&apos;#welcome&apos;).text()).toContain(&apos;李磊@_@&apos;) expect(wrapper.find(&apos;#userInput&apos;).exists()).toBeFalsy() &#125;) &#125;) describe(&apos;click footer to back&apos;, ()=&gt; &#123; it(&apos;should show welcome page, and original view disappear&apos;, ()=&gt; &#123; fillin(&apos;#userName&apos;, &apos;linTao123&apos;) wrapper.find(&apos;form&apos;).simulate(&apos;submit&apos;) wrapper.find(&apos;a&apos;).simulate(&apos;click&apos;) expect(wrapper.find(&apos;#userInput&apos;).exists()).toBeTruthy() &#125;) &#125;)&#125;) simulate方法是enzyme封装好的模拟页面元素事件的方法，用来模拟&quot;click&quot;,&quot;submit&quot;,&quot;change&quot;,&quot;doubeClick&quot;等事件。 测试代码中的fillin方法实现的是在渲染后的DOM中找到一个web element，然后用simulate方法模拟绑定在该元素上面的onChange()事件。 beforeEach方法是一个JEST的Hook，在每一个it/test开头的测试之前都会执行里面的内容。在demo的案例中，我把store.js和provider.js里面的内容照搬了过来，每个测试执行前都会新生成一个store，实现重置store的功能（重置测试环境）。 功能测试看上去也没问题了，所有的用户场景貌似都覆盖完了。这个时候我们再来检查下覆盖率 1npm test -- --coverage 100%覆盖率了有木有！完美啊有木有！为何加上功能测试以后，之前UI组件里面没有测试到的方法也被覆盖到了呢？分析下产品代码，原来是在页面元素上执行操作的时候，就会调用到UI组件上的这些方法，而这些操作后来被功能测试覆盖到了。 这么一来，又避免了重复的测试代码 :） 引自： https://testerhome.com/topics/8032","tags":[{"name":"个人整理","slug":"个人整理","permalink":"http://www.g5kk.com/tags/个人整理/"}]},{"title":"React组件自动化文档","date":"2017-05-16T15:20:39.000Z","path":"2017/05/16/react-auto-doc/","text":"构建和共享组件是React最强大的功能之一，但是没有任何文档，我们的组件有什么好处？ 我最近参与了一个项目，创建了将被广泛开发人员采用的组件，并且已经学会了一种方便自动化组件文档的方法 在这篇文章中，我们将介绍为什么您可能需要记录您的组件，以及如何使用React轻松实现。 为什么要做文档组件？那么首先你可能会想，为什么我们需要记录我们的组件？说实话，这真的取决于你正在建造什么，谁将会消耗你的组件。在我们的测试中构建Web应用程序时，可能会为我们的组件提供足够的文档。但是，如果您在整个业务或在线社区中使用大量应用程序或大量组件，那么文档就是关键。如果我们看一些例如React Bootstrap或Material UI，他们的文档真的可以帮助开发人员在几分钟之内完成设置并利用它们的组件。从这些项目中吸取灵感，我想为我的项目做类似的事情，并设法使用我在路上找到的一些令人敬畏的工具。 所以我们来看看他们。 react-docgenreact-docgen是一个CLI和工具箱，用于从React组件中提取信息，并从中生成文档。 这个想法很简单 我们将组件传递给反应文件，它将返回一个对象。 让我们来看看这个反馈文档GitHub页面上的例子。 Component Example123456789101112131415161718192021222324252627282930313233343536var React = require(&apos;react&apos;);/** * General component description. */var Component = React.createClass(&#123; propTypes: &#123; /** * Description of prop &quot;foo&quot;. */ foo: React.PropTypes.number, /** * Description of prop &quot;bar&quot; (a custom validation function). */ bar: function(props, propName, componentName) &#123; // ... &#125;, baz: React.PropTypes.oneOfType([ React.PropTypes.number, React.PropTypes.string ]), &#125;, getDefaultProps: function() &#123; return &#123; foo: 42, bar: 21 &#125;; &#125;, render: function() &#123; // ... &#125;&#125;);module.exports = Component; JSON output123456789101112131415161718192021222324252627282930313233343536373839404142&#123; &quot;props&quot;: &#123; &quot;foo&quot;: &#123; &quot;type&quot;: &#123; &quot;name&quot;: &quot;number&quot; &#125;, &quot;required&quot;: false, &quot;description&quot;: &quot;Description of prop \\&quot;foo\\&quot;.&quot;, &quot;defaultValue&quot;: &#123; &quot;value&quot;: &quot;42&quot;, &quot;computed&quot;: false &#125; &#125;, &quot;bar&quot;: &#123; &quot;type&quot;: &#123; &quot;name&quot;: &quot;custom&quot; &#125;, &quot;required&quot;: false, &quot;description&quot;: &quot;Description of prop \\&quot;bar\\&quot; (a custom validation function).&quot;, &quot;defaultValue&quot;: &#123; &quot;value&quot;: &quot;21&quot;, &quot;computed&quot;: false &#125; &#125;, &quot;baz&quot;: &#123; &quot;type&quot;: &#123; &quot;name&quot;: &quot;union&quot;, &quot;value&quot;: [ &#123; &quot;name&quot;: &quot;number&quot; &#125;, &#123; &quot;name&quot;: &quot;string&quot; &#125; ] &#125;, &quot;required&quot;: false, &quot;description&quot;: &quot;&quot; &#125; &#125;, &quot;description&quot;: &quot;General component description.&quot;&#125; 我们返回的JSON对象已经从我们的组件中提取了文档。 对象包含我们在组件中定义的所有属性。 对于每个prop的返回类型，如果必须，说明和任何默认值。 所以使用CLI是好的，但是我们如何在React应用程序中使用它并自动化进程？ 它实际上很直接，所以让我们来看看。 如何在React中使用react-docgen首先, 安装 react-docgen1npm install --save react-docgen 接下来, 导入 react-docgen1import &#123;parse&#125; from &apos;react-docgen&apos;; 现在我们可以解析任何组件并获取文档。 但是要使用解析函数，我们需要将组件转为string。 所以我们可以使用raw-loader将一个组件作为一个字符串导入 安装raw-loader1npm install raw-loader 在使用webpack设置raw-loader后，我们可以以原始格式导入任何文件。以原始格式导入文件1import Component from &apos;!raw!./Component&apos;; 注意：组件将作为字符串而不是React组件返回给我们。使用组件作为字符串，我们可以将它从反馈文档传递给我们的解析函数，以获取一些文档 1234import &#123;parse&#125; from &apos;react-docgen&apos;;import Component from &apos;!raw!./Component&apos;;const componentDocs = parse(Component); 在这个示例中，componentDocs将组件文档保存为JSON对象。 这是什么意思？对于能够从我们的组件获取文档的大规模的React应用程序可能是一个好主意。 使用react-docgen和raw-loader，我们可以轻松创建一个简单的用户界面来表示我们的组件库及其文档，供其他开发人员使用。 使用这些信息，我们可以直观地显示我们使用的组件，我们的组件道具细节和组件描述。 这是一个我一直在做的工作的例子，你可以通过react-docgen来实现。 Basic React应用程序，用于呈现组件文档 Button的描述和道具在组件更改时自动生成，确保文档始终保持最新的其他开发人员。 这个帖子的灵感来自于在GitHub上material-ui项目。 在GitHub上检查material-ui项目，了解如何使用此技术来帮助驱动其组件文档的一些很棒的例子。 如果您有任何问题告诉我，或发表评论。 本文译自: http://www.davidboyne.co.uk/2016/05/26/automating-react-documentation.html 另一篇文档参考: http://www.seekjune.com/post/8426","tags":[{"name":"个人整理","slug":"个人整理","permalink":"http://www.g5kk.com/tags/个人整理/"}]},{"title":"reactNative 热更新方法","date":"2017-05-13T12:48:01.000Z","path":"2017/05/13/react-native-code-push/","text":"1、安装code-push1npm install -g code-push-cli 新用户code-push register会要求用户登录github账户或 微软账户、登录成功后会返回一个key, 输入这个key的值 相关命令: code-push login 登陆 code-push loout 注销 code-push access-key ls 列出登陆的token code-push access-key rm 删除某个 key值 2、在CodePush上注册app1code-push app add &lt;appName&gt; 返回如下表格Name | Deployment Key—|—Production | SeGH3j6xEzTU54TWEDMbmFVkJuTRE1IE1U50MStaging | VfzbGk_YDjTyV8DOtGR3PE1yQ46VE1IE1U50M 相关命令:12345678910add Add a new app to your accountremove Remove an app from your accountrm Remove an app from your accountrename Rename an existing applist Lists the apps associated with your accountls Lists the apps associated with your accounttransfer Transfer the ownership of an app to another accountOptions: -v, --version Show version number [boolean] 3、项目中添加code-push12npm install --save react-native-code-push@latestrnpm link react-native-code-push 检查 android/app/build.gradle, 添加1apply from: &quot;../../node_modules/react-native-code-push/android/codepush.gradle&quot; 4、添加部署key查看部署的key1code-push deployment ls &lt;appName&gt; -k 默认的部署名是 staging，所以部署秘钥就是staging在android目录下新建local.properties文件12code_push_key_production=SeGH3j6xEzTU54TWEDMbmFVkJuTRE1IE1U50Mcode_push_key_staging=VfzbGk_YDjTyV8DOtGR3PE1yQ46VE1IE1U50M 配置 android/app/build.gradle1234567891011121314buildTypes &#123; ... releaseStaging &#123; ... buildConfigField &quot;String&quot;, &quot;CODEPUSH_KEY&quot;, &apos;&quot;&apos;+properties.getProperty(&quot;code_push_key_production&quot;)+&apos;&quot;&apos; ... &#125; release &#123; ... buildConfigField &quot;String&quot;, &quot;CODEPUSH_KEY&quot;, &apos;&quot;&apos;+properties.getProperty(&quot;code_push_key_staging&quot;)+&apos;&quot;&apos; ... &#125;&#125; 更新 MainApplication.java文件1234return Arrays.&lt;ReactPackage&gt;asList( new MainReactPackage(), new CodePush(BuildConfig.CODEPUSH_KEY, MainApplication.this, BuildConfig.DEBUG)); 5、修改versionName在 android/app/build.gradle 中有个 android.defaultConfig.versionName属性，我们需要把 应用版本改成 1.0.0（默认是1.0，但是codepush需要三位数） 至此Code-Push 集成完毕。进入 android目录执行gradlew assembleRelease进行一次打包， 看下是否会存在错误， 若出现 No signature of method: java.util.LinkedHashMap.getProperty() is applicable for argument types: (java.lang.String) values:[code_push_key_production] 可能是因react-native 不支持local.properties文件方式保存，修改build.gradle1234567891011buildTypes &#123; releaseStaging &#123; buildConfigField &quot;String&quot;, &quot;CODEPUSH_KEY&quot;, &apos;&quot;SeGH3j6xEzTU54TWEDMbmFVkJuTRE1IE1U50M&quot;&apos; &#125; release &#123; minifyEnabled enableProguardInReleaseBuilds proguardFiles getDefaultProguardFile(&quot;proguard-android.txt&quot;), &quot;proguard-rules.pro&quot; signingConfig signingConfigs.release buildConfigField &quot;String&quot;, &quot;CODEPUSH_KEY&quot;, &apos;&quot;VfzbGk_YDjTyV8DOtGR3PE1yQ46VE1IE1U50M&quot;&apos; &#125;&#125; 注意&#39;&quot;SeGH3j6xEzTU54TWEDMbmFVkJuTRE1IE1U50M&quot;&#39;中的单引号不能去掉， 否则会报错12345错误: 找不到符号 public static final String CODEPUSH_KEY = VfzbGk_YDjTyV8DOtGR3PE1yQ46VE1IE1U50M; ^ 符号: 变量 VfzbGk_YDjTyV8DOtGR3PE1yQ46VE1IE1U50M 位置: 类 BuildConfig 6、添加更新监听部署完code-push后接下来有两步要做 什么时候检查更新 （在APP启动的时候？在设置页面添加一个检查更新按钮？） 什么时候可以更新，如何将更新呈现给终端用户？ 如果有发布热更新时 mandatory 则 Code Push 会根据 mandatory 是 true 或false 来控制应用是否强制更新。默认情况下 mandatory 为 false 即不强制更新。mandatory 为 false时以下三种设置方法才有效1234567891011121314151617181920// 第一种:codePush.sync();// 第二种:codePush.sync(&#123; updateDialog: false, installMode: codePush.InstallMode.IMMEDIATE&#125;);// 第三种:CodePush.sync(&#123; deploymentKey: &apos;deployment-key-here&apos;, updateDialog: &#123; optionalIgnoreButtonLabel: &apos;稍后&apos;, optionalInstallButtonLabel: &apos;后台更新&apos;, optionalUpdateMessage: &apos;有新版本了，是否更新？&apos;, title: &apos;更新提示&apos; &#125;, installMode: CodePush.InstallMode.IMMEDIATE&#125;); 三种更新的策略: 配置到installMode: 之后即可生效 IMMEDIATE 立即更新APP ON_NEXT_RESTART 到下一次启动应用时 ON_NEXT_RESUME 当应用从后台返回时 7、打包发布方法1: 只打包js文件,创建一个bundles文件夹12打包命令: react-native bundle --platform 平台 --entry-file 启动文件 --bundle-output 打包js输出文件 --assets-dest 资源输出目录 --dev 是否调试 eg: 1react-native bundle --platform android --entry-file index.android.js --bundle-output ./bundles/index.android.bundle --dev false 发布更新 发布命令:1ode-push release &lt;应用名称&gt; &lt;Bundles所在目录&gt; &lt;对应的应用版本&gt; --deploymentName 更新环境 --description 更新描述 --mandatory 是否强制更新 eg:1code-push release DemoApp ./bundles/index.android.bundle 1.0.0 --deploymentName Production --description &quot;第1次更新&quot; --mandatory true 方法2： 打包js + 图片资源 1react-native bundle --platform android --entry-file index.android.js --bundle-output ./bundles/index.android.bundle --assets-dest ./bundles --dev false –assets-dest 后就是放图片的文件夹路径 push bundles文件1code-push &lt;release/debug&gt; &lt;projectName(与注册的app同名)&gt;&lt;bundle文件名&gt; &lt;版本号&gt; eg :1code-push release appName ./bundles 1.0.0 8、更新规则你APP内plist文件写的版本号可能是1.0.0，所以你的reactjs打包上传的版本也要是1.0.0（而不是1.0.1这样递增），你需要和APP保持一致，然后服务器会根据你最新上传的且和APP一样的版本作为最新版。 9、修改更新123456789101112Usage: code-push patch &lt;appName&gt; &lt;deploymentName&gt; [--label &lt;label&gt;] [--description &lt;description&gt;] [--disabled] [--mandatory] [--rollout &lt;rolloutPercentage&gt;]选项： --label, -l 指定标签版本更新，默认最新版本 [string] [默认值: null] --description, --des 描述 [string] [默认值: null] --disabled, -x 是否禁用该更新 [boolean] [默认值: null] --mandatory, -m 是否强制更新 [boolean] [默认值: null] --rollout, -r 此更新推送用户的百分比，此值仅可以从先前的值增加。 [string] [默认值: null]示例： code-push patch MyApp Production --des &quot;Updated description&quot; -r 50 修改&quot;MyApp&quot;的&quot;Production&quot;部署中最新更新的描述 ，并且更新推送范围为50％ code-push patch MyApp Production -l v3 --des &quot;Updated description for v3&quot; 修改&quot;MyApp&quot;的&quot;Production&quot;部署中标签为v3的更新的描述 10、升级环境1234567891011Usage: code-push promote &lt;appName&gt; &lt;sourceDeploymentName&gt; &lt;destDeploymentName&gt; [--description &lt;description&gt;] [--mandatory] [--rollout &lt;rolloutPercentage&gt;]选项： --description, --des 描述 [string] [默认值: null] --disabled, -x 是否禁用该更新 [boolean] [默认值: null] --mandatory, -m 是否强制更新 [boolean] [默认值: null] --rollout, -r 此促进更新推送用户的百分比 [string] [默认值: null]示例： code-push promote MyApp Staging Production &quot;MyApp&quot;中&quot;Staging&quot;部署的最新更新发布到&quot;Production&quot;部署中 code-push promote MyApp Staging Production --des &quot;Production rollout&quot; -r 25 &quot;MyApp&quot;中&quot;Staging&quot;部署的最新更新发布到&quot;Production&quot;部署中, 并且只推送25%的用户 11、回滚更新12345678Usage: code-push rollback &lt;appName&gt; &lt;deploymentName&gt; [--targetRelease &lt;releaseLabel&gt;]选项： --targetRelease, -r 指定回归到哪个标签，默认是回滚到上一个更新 [string] [默认值: null]示例： code-push rollback MyApp Production &quot;MyApp&quot;中&quot;Production&quot;部署执行回滚 code-push rollback MyApp Production --targetRelease v4 &quot;MyApp&quot;中&quot;Production&quot;部署执行回滚，回滚到v4这个标签版本 注： 本博文来自网络","tags":[{"name":"reactNative","slug":"reactNative","permalink":"http://www.g5kk.com/tags/reactNative/"}]},{"title":"列出两个日期之间的所有天","date":"2017-05-12T14:03:57.000Z","path":"2017/05/12/list-between-day/","text":"1234567891011121314151617181920212223242526272829303132333435363738394041/** * 列出两个日期之间所有的天 * @param &#123;[type]&#125; a [description] * @param &#123;[type]&#125; b [description] * @return &#123;[Array]&#125; [description] [&apos;03/16&apos;, &apos;03/17&apos;] */ function listDiffDay(start, end) &#123; if (!start || !end) return; var resultData = []; // 日期格式必须是YYYY-MM-DD var regExp = /((((1[6-9]|[2-9]\\d)\\d&#123;2&#125;)-(1[02]|0?[13578])-([12]\\d|3[01]|0?[1-9]))|(((1[6-9]|[2-9]\\d)\\d&#123;2&#125;)-(1[012]|0?[13456789])-([12]\\d|30|0?[1-9]))|(((1[6-9]|[2-9]\\d)\\d&#123;2&#125;)-0?2-(1\\d|2[0-8]|0?[1-9]))|(((1[6-9]|[2-9]\\d)(0[48]|[2468][048]|[13579][26])|((16|[2468][048]|[3579][26])00))-0?2-29-))/ // console.log(regExp.test(start)) if (regExp.test(start) &amp;&amp; regExp.test(end)) &#123; var s = start.split(&quot;-&quot;); var e = end.split(&quot;-&quot;); var d = new Date(); var i = 0; var oneDay = 24 * 60 * 60 * 1000; // 设置开始的日期 d.setDate(s[2]) d.setMonth(s[1] - 1); d.setFullYear(s[0]); while (i == 0) &#123; var c = d.getTime() + oneDay; // 增加一天的时间数 d.setTime(c); var this_date = d.getDate(); var this_month = d.getMonth() + 1; var this_year = d.getFullYear(); this_date = this_date &lt; 10 ? (&apos;0&apos;+ this_date): this_date; this_month = this_month &lt; 10? (&apos;0&apos;+ this_month): this_month; resultData.push(this_month +&apos;/&apos;+ this_date); if (this_year == e[0] &amp;&amp; this_month == e[1] &amp;&amp; this_date == e[2]) &#123; i = 1; &#125; &#125; &#125; return resultData; &#125; 调用 `console.log(listDiffDay(&apos;2017-02-20&apos;, 2017-03-10&apos;))`","tags":[{"name":"个人整理","slug":"个人整理","permalink":"http://www.g5kk.com/tags/个人整理/"}]},{"title":"Git相关收集","date":"2017-05-12T10:20:39.000Z","path":"2017/05/12/git-collect/","text":"Clone从远程仓库下载代码到本地1git clone https://github.com/jys0909/ysblog.git 更新代码从远程仓库更新代码1git pull 分支12git branch // 分支列表git branch devlopment // 添加分支 切换分支1git checkout devlopment 提交代码123git add .git commit -m &apos;decription&apos;git push 提交本地分支到远程仓库1git push origin devlopment:devlopment 这个操作如果远程仓库已存在devlopment分支， 则为更新 全局设置12git config --global user.name &quot;xxx&quot;git config --global user.email &quot;xxx&quot; git pull失败,提示：==fatal: refusing to merge unrelated histories==git pull 时添加参数1git pull origin master --allow-unrelated-histories 可以参考网址 git clone 时提示 Could not read from remote repository有可能是使用的是 ssh 方式，在提示yes的时候没写正确, 使用https git add 时提示 warning: LF will be replaced by CRLF1git config --global core.autocrlf false","tags":[{"name":"个人整理","slug":"个人整理","permalink":"http://www.g5kk.com/tags/个人整理/"}]},{"title":"React组件生命周期","date":"2017-05-12T10:08:56.000Z","path":"2017/05/12/react-component-life-cycle/","text":"1234567891011121314151617181920212223242526272829303132333435363738394041424344454647// 字义组件class TodoList extends React.Component &#123; // 构造函数，在创建组件的时候调用一次 constructor(props, context) &#123; ... &#125; // 在组件挂载之前调用一次,如果在这个函数里面调用setState，本次的render函数可以看到更新后的state，并且只渲染一次 void componentWillMount() &#123; ... &#125; // 在组件挂载之后调用一次。这个时候，子主键也都挂载好了，可以在这里使用refs void componentDidMount() &#123; ... &#125; // props是父组件传递给子组件的。父组件发生render的时候子组件就会调用componentWillReceiveProps（不管props有没有更新，也不管父子组件之间有没有数据交换）。 void componentWillReceiveProps(nextProps) &#123; ... &#125; // 组件挂载之后，每次调用setState后都会调用shouldComponentUpdate判断是否需要重新渲染组件。默认返回true，需要重新render。在比较复杂的应用里，有一些数据的改变并不影响界面展示，可以在这里做判断，优化渲染效率。 bool shouldComponentUpdate(nextProps, nextState) &#123; return true &#125; // shouldComponentUpdate返回true或者调用forceUpdate之后，componentWillUpdate会被调用。 void componentWillUpdate(nextProps, nextState) &#123; ... &#125; // 除了首次render之后调用componentDidMount，其它render结束之后都是调用componentDidUpdate。 void componentDidUpdate() &#123; &#125; // 组件被卸载的时候调用。一般在componentDidMount里面注册的事件需要在这里删除。 void componentWillUnmount() &#123; &#125; // componentWillMount、componentDidMount和componentWillUpdate、componentDidUpdate可以对应起来。区别在于，前者只有在挂载的时候会被调用；而后者在以后的每次更新渲染之后都会被调用 // render是一个React组件所必不可少的核心函数（上面的其它函数都不是必须的）。记住，不要在render里面修改state。 render() &#123; return ( &lt;div&gt; ... &lt;/div&gt; ) &#125;&#125; 来源：http://www.jianshu.com/p/4784216b8194","tags":[{"name":"个人整理","slug":"个人整理","permalink":"http://www.g5kk.com/tags/个人整理/"}]},{"title":"lodash 常用函数","date":"2017-05-11T17:09:49.000Z","path":"2017/05/11/loadsh/","text":"_.filter 遍历 collection（集合）元素，返回 predicate（断言函数）返回真值 的所有元素的数组。 predicate（断言函数）调用三个参数：(value, index|key, collection)。返回一个新的过滤后的数组。 12345678910111213141516171819var users = [ &#123; &apos;user&apos;: &apos;barney&apos;, &apos;age&apos;: 36, &apos;active&apos;: true &#125;, &#123; &apos;user&apos;: &apos;fred&apos;, &apos;age&apos;: 40, &apos;active&apos;: false &#125;]; _.filter(users, function(o) &#123; return !o.active; &#125;);// =&gt; objects for [&apos;fred&apos;] // The `_.matches` iteratee shorthand._.filter(users, &#123; &apos;age&apos;: 36, &apos;active&apos;: true &#125;);// =&gt; objects for [&apos;barney&apos;] // The `_.matchesProperty` iteratee shorthand._.filter(users, [&apos;active&apos;, false]);// =&gt; objects for [&apos;fred&apos;] // The `_.property` iteratee shorthand._.filter(users, &apos;active&apos;);// =&gt; objects for [&apos;barney&apos;] _.find 遍历 collection（集合）元素，返回 predicate（断言函数）第一个返回真值的第一个元素。predicate（断言函数）调用3个参数： (value, index|key, collection)。返回匹配元素，否则返回 undefined。 1234567891011121314151617181920var users = [ &#123; &apos;user&apos;: &apos;barney&apos;, &apos;age&apos;: 36, &apos;active&apos;: true &#125;, &#123; &apos;user&apos;: &apos;fred&apos;, &apos;age&apos;: 40, &apos;active&apos;: false &#125;, &#123; &apos;user&apos;: &apos;pebbles&apos;, &apos;age&apos;: 1, &apos;active&apos;: true &#125;]; _.find(users, function(o) &#123; return o.age &lt; 40; &#125;);// =&gt; object for &apos;barney&apos; // The `_.matches` iteratee shorthand._.find(users, &#123; &apos;age&apos;: 1, &apos;active&apos;: true &#125;);// =&gt; object for &apos;pebbles&apos; // The `_.matchesProperty` iteratee shorthand._.find(users, [&apos;active&apos;, false]);// =&gt; object for &apos;fred&apos; // The `_.property` iteratee shorthand._.find(users, &apos;active&apos;);// =&gt; object for &apos;barney&apos; _.forEach 调用 iteratee 遍历 collection(集合) 中的每个元素， iteratee 调用3个参数： (value, index|key, collection)。 如果迭代函数（iteratee）显式的返回 false ，迭代会提前退出。返回集合 collection。 123456789_([1, 2]).forEach(function(value) &#123; console.log(value);&#125;);// =&gt; Logs `1` then `2`. _.forEach(&#123; &apos;a&apos;: 1, &apos;b&apos;: 2 &#125;, function(value, key) &#123; console.log(key);&#125;);// =&gt; Logs &apos;a&apos; then &apos;b&apos; (iteration order is not guaranteed). _.map 创建一个数组， value（值） 是 iteratee（迭代函数）遍历 collection（集合）中的每个元素后返回的结果。 iteratee（迭代函数）调用3个参数：(value, index|key, collection). lodash 中有许多方法是防止作为其他方法的迭代函数（愚人码头注：即不能作为iteratee参数传递给其他方法），例如： .every, .filter, .map, .mapValues, .reject, 和 .some。 受保护的方法有（愚人码头注：即这些方法不能使用.every, .filter, .map, .mapValues, .reject, 和 .some作为 iteratee 迭代函数参数） ：ary, chunk, curry, curryRight, drop, dropRight, every, fill, invert, parseInt, random, range, rangeRight, repeat, sampleSize, slice, some, sortBy, split, take, takeRight, template, trim, trimEnd, trimStart, and words返回新的映射后数组。 123456789101112131415161718function square(n) &#123; return n * n;&#125; _.map([4, 8], square);// =&gt; [16, 64] _.map(&#123; &apos;a&apos;: 4, &apos;b&apos;: 8 &#125;, square);// =&gt; [16, 64](iteration order is not guaranteed) var users = [ &#123; &apos;user&apos;: &apos;barney&apos; &#125;, &#123; &apos;user&apos;: &apos;fred&apos; &#125;]; // The `_.property` iteratee shorthand._.map(users, &apos;user&apos;);// =&gt; [&apos;barney&apos;, &apos;fred&apos;] _.orderBy 此方法类似于_.sortBy，除了它允许指定 iteratee（迭代函数）结果如何排序。 如果没指定 orders（排序），所有值以升序排序。 否则，指定为”desc” 降序，或者指定为 “asc” 升序，排序对应值。返回排序后的新数组。 12345678910var users = [ &#123; &apos;user&apos;: &apos;fred&apos;, &apos;age&apos;: 48 &#125;, &#123; &apos;user&apos;: &apos;barney&apos;, &apos;age&apos;: 34 &#125;, &#123; &apos;user&apos;: &apos;fred&apos;, &apos;age&apos;: 40 &#125;, &#123; &apos;user&apos;: &apos;barney&apos;, &apos;age&apos;: 36 &#125;]; // 以 `user` 升序排序 再 `age` 以降序排序。_.orderBy(users, [&apos;user&apos;, &apos;age&apos;], [&apos;asc&apos;, &apos;desc&apos;]);// =&gt; objects for [[&apos;barney&apos;, 36], [&apos;barney&apos;, 34], [&apos;fred&apos;, 48], [&apos;fred&apos;, 40]] _.clone 创建一个 value 的浅拷贝。 注意: 这个方法参考自 structured clone algorithm 以及支持 arrays、array buffers、 booleans、 date objects、maps、 numbers， Object 对象, regexes, sets, strings, symbols, 以及 typed arrays。 arguments对象的可枚举属性会拷贝为普通对象。 一些不可拷贝的对象，例如error objects、functions, DOM nodes, 以及 WeakMaps 会返回空对象。返回拷贝后的值 12345 var objects = [&#123; &apos;a&apos;: 1 &#125;, &#123; &apos;b&apos;: 2 &#125;]; var shallow = _.clone(objects);console.log(shallow[0] === objects[0]);// =&gt; true 续更新… 来源： http://www.css88.com/doc/lodash/#_forinobject-iteratee_identity","tags":[{"name":"个人整理","slug":"个人整理","permalink":"http://www.g5kk.com/tags/个人整理/"}]},{"title":"windows Node 版本管理","date":"2017-05-11T14:56:00.000Z","path":"2017/05/11/node-version-manager/","text":"1、下载 nvm-windows 是 Windows 下的 Node.js 版本管理工具 下载 nvm-window包, 选择最新版本nvm-setup包, 然后进行安装 安装成功后查看下环境变量是否正常$ nvm version 可查看版本 2、使用方法1234nvm install v6.10.3 // 安装node 版本nvm uninstall v6.10.3 // 卸载node 版本nvm use v6.10.3 // 使用node版本nvm help // 查看帮助","tags":[{"name":"node","slug":"node","permalink":"http://www.g5kk.com/tags/node/"}]},{"title":"ReactNative 打开手机WiFi设置","date":"2017-05-11T14:03:16.000Z","path":"2017/05/11/openAndroidSetting/","text":"安装包1npm install react-native-android-settings-library --save 配置 打开 android/settings.gradle 添加如下代码 12include &apos;:react-native-android-settings-library&apos;project(&apos;:react-native-android-settings-library&apos;).projectDir = new File(rootProject.projectDir, &apos;../node_modules/react-native-android-settings-library/android&apos;) 打开 android/app/build.gradle 添加如下代码 1234dependencies &#123; // add here compile project(&apos;:react-native-android-settings-library&apos;)&#125; 打开 MainApplication.java 添加如下代码; 1234import com.reactlibrary.androidsettings.RNANAndroidSettingsLibraryPackage;// 主体new RNANAndroidSettingsLibraryPackage() 引入包123import RNANAndroidSettingsLibrary from &apos;react-native-android-settings-library&apos;;RNANAndroidSettingsLibrary.open(&apos;ACTION_WIFI_SETTINGS&apos;); open参数如下： ACTION_SETTINGS ACTION_WIRELESS_SETTINGS ACTION_AIRPLANE_MODE_SETTINGS ACTION_WIFI_SETTINGS // 打开wifi 开关 ACTION_APN_SETTINGS ACTION_BLUETOOTH_SETTINGS ACTION_DATE_SETTINGS ACTION_LOCALE_SETTINGS ACTION_INPUT_METHOD_SETTINGS ACTION_DISPLAY_SETTINGS ACTION_SECURITY_SETTINGS ACTION_LOCATION_SOURCE_SETTINGS ACTION_INTERNAL_STORAGE_SETTINGS ACTION_MEMORY_CARD_SETTINGS ACTION_APPLICATION_DETAILS_SETTINGS","tags":[{"name":"reactNative","slug":"reactNative","permalink":"http://www.g5kk.com/tags/reactNative/"}]},{"title":"关闭win10自动更新","date":"2017-05-11T11:38:33.000Z","path":"2017/05/11/win10Update/","text":"方法1windows+R 进入 cmd -&gt; gpedit.msc找到window更新，如下图: 方法2打开服务， 找到Windows Update ， 双击打开， 选择禁止，并停止服务","tags":[{"name":"个人整理","slug":"个人整理","permalink":"http://www.g5kk.com/tags/个人整理/"}]},{"title":"搭建开发环境","date":"2017-05-10T16:56:29.000Z","path":"2017/05/10/reactNativeSetup/","text":"1、安装ChocolateyChocolatey是一个Windows上的包管理器，类似于linux上的yum和 apt-get。 你可以在其官方网站上查看具体的使用说明。一般的安装步骤应该是下面这样1@powershell -NoProfile -ExecutionPolicy Bypass -Command &quot;iex ((new-object net.webclient).DownloadString(&apos;https://chocolatey.org/install.ps1&apos;))&quot; &amp;&amp; SET PATH=%PATH%;%ALLUSERSPROFILE%\\chocolatey\\bin 2、安装Python 2安装了Chocolatey后就可以使用下面的命令了1choco install python2 注意目前不支持Python 3版本。 3、NodeNode环境是必须的，使用稳定版本，不要使用cnpm加速，可用如下加速镜像12npm config set registry https://registry.npm.taobao.org --globalnpm config set disturl https://npm.taobao.org/dist --global 4、Yarn、React Native的命令行工具（react-native-cli）Yarn是Facebook提供的替代npm的工具，可以加速node模块的下载。React Native的命令行工具用于执行创建、初始化、更新项目、运行打包服务（packager）等任务。1npm install -g yarn react-native-cli 安装完yarn后同理也要设置镜像源：12yarn config set registry https://registry.npm.taobao.org --globalyarn config set disturl https://npm.taobao.org/dist --global 5、Android Studio 它不是必须的，主要是为了使用里面的SDK, 版本2.0以上Android Studio需要Java Development Kit [JDK]1.8或更高版本。你可以在命令行中输入 javac-version来查看你当前安装的JDK版本。如果版本不合要求，则可以到 官网上下载。 6、ANDROID_HOME环境变量确保ANDROID_HOME环境变量正确地指向了你安装的Android SDK的路径。 打开控制面板 -&gt; 系统和安全 -&gt; 系统 -&gt; 高级系统设置 -&gt; 高级 -&gt; 环境变量 -&gt; 新建 7、配置Android Studio 参数打开SDK Manager ， 配置如下几个参数 8、安装模拟器 Genymotion比起Android Studio自带的原装模拟器，Genymotion是一个性能更好的选择，但它只对个人用户免费。 下载和安装Genymotion（genymotion需要依赖VirtualBox虚拟机，下载选项中提供了包含VirtualBox和不包含的选项，请按需选择）。 打开Genymotion。如果你还没有安装VirtualBox，则此时会提示你安装。 创建一个新模拟器并启动。 启动React Native应用后，可以按下F1来打开开发者菜单。 选择合适的下载安装 9、测试安装程序先打开模拟器， 当然使用真机也是可以的。真机的话需要打开USB调试模式123react-native init HelloWordcd HelloWordreact-native run-android 使用adb devices 查看当前设备","tags":[{"name":"reactNative","slug":"reactNative","permalink":"http://www.g5kk.com/tags/reactNative/"}]},{"title":"reactNative 打包测试","date":"2017-05-10T16:45:18.000Z","path":"2017/05/10/reactnative/","text":"1、生成密钥在项目根目录打开命令行（快捷方法：进入根目录win下按住shift键单击右键打开命令行，直接对应该目录）。然后输入1keytool -genkey -v -keystore my-release-key.keystore -alias my-key-alias -keyalg RSA -keysize 2048 -validity 10000 按要求填写相关信息后生成的 ==my-release-key.keystore== 文件放到你工程中的==android/app==文件夹下 2、修改gradle.properties文件在android目录下打开gradle.properties文件，添加如下代码：1234MYAPP_RELEASE_STORE_FILE=my-release-key.keystoreMYAPP_RELEASE_KEY_ALIAS=my-key-aliasMYAPP_RELEASE_STORE_PASSWORD=******* // 密钥口令MYAPP_RELEASE_KEY_PASSWORD=******* // 密钥口令 3、修改build.gradle文件在android/app目录下打开build.gradle文件，按如下格式修改:12345678910111213141516signingConfigs &#123; release &#123; storeFile file(MYAPP_RELEASE_STORE_FILE) storePassword MYAPP_RELEASE_STORE_PASSWORD keyAlias MYAPP_RELEASE_KEY_ALIAS keyPassword MYAPP_RELEASE_KEY_PASSWORD &#125;&#125;buildTypes &#123; release &#123; minifyEnabled enableProguardInReleaseBuilds proguardFiles getDefaultProguardFile(&quot;proguard-android.txt&quot;), &quot;proguard-rules.pro&quot; signingConfig signingConfigs.release &#125;&#125; 4、生成index.android.bundle文件在android\\app\\src\\main目录下新建名为assets的文件夹，然后在项目根目录的命令行下输入1react-native bundle --platform android --dev false --entry-file index.android.js \\ --bundle-output android/app/src/main/assets/index.android.bundle \\ --assets-dest android/app/src/main/res/ 5、生成APK在android目录命令行下输入==gradlew assembleRelease==，然后等待几分钟，在==android/app/build/outputs/apk==目录下找到APK文件。 注意事项: 打包前最好删除app\\build文件夹 src\\main 下面的资源不能出现相同名称 其他可能出现的问题记录在此 1、==unable to process incoming event ‘ProcessComplete’==在/android/目录中执行==gradle assembleRelease==命令 如果出现此类错误，清理下，在==proguard-rules.pro==中加入12-keep class android.text &#123;* ;&#125;-dontwarn android.text.*","tags":[{"name":"reactNative","slug":"reactNative","permalink":"http://www.g5kk.com/tags/reactNative/"}]},{"title":"Markdown 语法的简要规则","date":"2017-05-10T16:37:35.000Z","path":"2017/05/10/markdown/","text":"标题标题是每篇文章都需要也是最常用的格式，在 Markdown 中，如果一段文字被定义为标题，只要在这段文字前加 # 号即可。123# 一级标题## 二级标题### 三级标题 以此类推 共6级 列表熟悉 HTML 的同学肯定知道有序列表与无序列表的区别，在 Markdown 下，列表的显示只需要在文字前加上 - 或 * 即可变为无序列表，有序列表则直接在文字前加1. 2. 3. 符号要和文字之间加上一个字符的空格。 a b A B C 引用如果你需要引用一小段别处的句子，那么就要用引用的格式。只需要在文本前加入 &gt; 这种尖括号（大于号）即可 引用 图片与链接12345插入链接与插入图片的语法很像，区别在一个 !号图片为：![]()链接为：[]()插入图片的地址需要图床，这里推荐围脖图床修复计划 与CloudApp 的服务，生成URL地址即可。 Baidu Baidu 粗体与斜体Markdown 的粗体和斜体也非常简单，用两个 包含一段文本就是粗体的语法，用一个 包含一段文本就是斜体的语法。例如：这里是粗体 这里是斜体 表格表格是 Markdown 比较累人的地方，例子如下：| Tables | Are | Cool || ————- |:————-:| —–:|| col 3 is | right-aligned | $1600 || col 2 is | centered | $12 || zebra stripes | are neat | $1 | 代码框如果你是个程序猿，需要在文章里优雅的引用代码框，在 Markdown下实现也非常简单，只需要用三个 ` 把中间的代码包裹起来。图例： 1234var a = 10;var obj = &#123;&#125; 分割线分割线的语法只需要三个 * 号 到这里，Markdown 的基本语法在日常的使用中基本就没什么大问题了，只要多加练习，配合好用的工具，写起东西来肯定会行云流水。更多的语法规则，其实 Mou 的 Help 文档栗子很好，当你第一次使用 Mou 时，就会显示该文档。可以用来对用的查找和学习。 Mark文字使用两个=号包起来, 例如: 下面的文字是==重点== 选择树结构 [ ] 节点1 [x] 节点1-1 [ ] 节点2 [x] 节点2-1 数学公式1E = mc^2 其他12graph LRA--&gt;B 123sequenceDiagramA-&gt;&gt;B: How are you?B-&gt;&gt;A: Great! 12345678ganttdateFormat YYYY-MM-DDsection S1T1: 2014-01-01, 9dsection S2T2: 2014-01-11, 9dsection S3T3: 2014-01-02, 9d 参考 有道云Markdown语法","tags":[{"name":"个人整理","slug":"个人整理","permalink":"http://www.g5kk.com/tags/个人整理/"}]},{"title":"利用Travis CI 让你的github项目持续构建","date":"2017-05-10T15:43:25.000Z","path":"2017/05/10/travis-ci/","text":"Travis CI 是目前新兴的开源持续集成构建项目，它与jenkins，GO的很明显的特别在于采用yaml格式，简洁清新独树一帜。目前大多数的github项目都已经移入到Travis CI的构建队列中，据说Travis CI每天运行超过4000次完整构建 搭建 Travis CI build，需要 github账号和github项目 用github账号登陆Travis CI. 在右上角你的账户名点击进入 ==account==，在==Repositories tab==页点击==Sync now==同步你的github项目 选中项目将默认的off改变为on开启项目的持续集成 在你项目的根目录建立一个.travis.yml文件，内容为12345678910111213141516171819202122232425262728language: node_jsnode_js: stable# S: Build Lifecycleinstall: - npm install# before_script: # -script: - hexo gafter_script: - cd ./public - git init - git config user.name &quot;jys0909&quot; - git config user.email &quot;276977683@qq.com&quot; - git add . - git commit -m &quot;Update docs&quot; - git push --force --quiet &quot;https://$&#123;GH_TOKEN&#125;@$&#123;GH_REF&#125;&quot; master:master# E: Build LifeCyclebranches: only: - blog-sourceenv: global: - GH_REF: github.com/jys0909/ysblog.git 来源： http://www.cnblogs.com/whitewolf/archive/2013/04/14/3019838.html","tags":[{"name":"个人整理","slug":"个人整理","permalink":"http://www.g5kk.com/tags/个人整理/"}]},{"title":"常用正则收录","date":"2017-05-10T14:21:09.000Z","path":"2017/05/10/regex/","text":"1、两位小数以内的正实数1^(([0-9]+)|([0-9]+\\.[0-9]&#123;1,2&#125;))$ 2、中文、字母、数字、或者下划线1/^[\\u4e00-\\u9fa5A-Za-z0-9_]+$/ 3、电话号码1/^(0[0-9]&#123;2,3&#125;\\-)?([2-9][0-9]&#123;6,7&#125;)+(\\-[0-9]&#123;1,4&#125;)?$|(^(13[0-9]|15[0|3|6|7|8|9]|18[8|9])\\d&#123;8&#125;$|(^400-([0-9])&#123;1&#125;([0-9-]&#123;6&#125;)([0-9])&#123;1&#125;)$)/ 4、网址1/^(f|ht)&#123;1&#125;(tp|tps):\\/\\/([\\w-]+\\.)+[\\w-]+(\\/[\\w- ./?%&amp;=]*)?/ 5、邮箱1\\w[-\\w.+]*@([A-Za-z0-9][-A-Za-z0-9]+\\.)+[A-Za-z]&#123;2,14&#125; 6、双字节字符1[^\\x00-\\xff] 7、时分秒1([01]?\\d|2[0-3]):[0-5]?\\d:[0-5]?\\d","tags":[{"name":"个人整理","slug":"个人整理","permalink":"http://www.g5kk.com/tags/个人整理/"}]}]